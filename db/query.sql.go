// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const actorMovies = `-- name: ActorMovies :many
SELECT m.id, m.title, m.description, m.release_date, m.rating 
FROM Movie m
LEFT JOIN MovieActor ma ON m.movie_id = ma.movie_id
WHERE ma.actor_id = 1
`

func (q *Queries) ActorMovies(ctx context.Context) ([]Movie, error) {
	rows, err := q.db.Query(ctx, actorMovies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ReleaseDate,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const clearDatabase = `-- name: ClearDatabase :exec
DROP TABLE AppUser
`

func (q *Queries) ClearDatabase(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearDatabase)
	return err
}

const createActor = `-- name: CreateActor :one
INSERT INTO Actor (
  name, birth, gender
) VALUES (
  $1, $2, $3
)
RETURNING id, name, gender, birth
`

type CreateActorParams struct {
	Name   string      `json:"name"`
	Birth  pgtype.Date `json:"birth"`
	Gender GenderType  `json:"gender"`
}

func (q *Queries) CreateActor(ctx context.Context, arg CreateActorParams) (Actor, error) {
	row := q.db.QueryRow(ctx, createActor, arg.Name, arg.Birth, arg.Gender)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Gender,
		&i.Birth,
	)
	return i, err
}

const createMovie = `-- name: CreateMovie :one
INSERT INTO Movie (
  title, description, release_date, rating
) VALUES (
  $1 ,$2, $3, $4 
)
RETURNING id, title, description, release_date, rating
`

type CreateMovieParams struct {
	Title       string         `json:"title"`
	Description pgtype.Text    `json:"description"`
	ReleaseDate pgtype.Date    `json:"release_date"`
	Rating      pgtype.Numeric `json:"rating"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg CreateMovieParams) (Movie, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.Title,
		arg.Description,
		arg.ReleaseDate,
		arg.Rating,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ReleaseDate,
		&i.Rating,
	)
	return i, err
}

const createMovieActor = `-- name: CreateMovieActor :exec
INSERT INTO MovieActor (
  movie_id, actor_id
) VALUES (
  $1, $2
)
`

type CreateMovieActorParams struct {
	MovieID int32 `json:"movie_id"`
	ActorID int32 `json:"actor_id"`
}

func (q *Queries) CreateMovieActor(ctx context.Context, arg CreateMovieActorParams) error {
	_, err := q.db.Exec(ctx, createMovieActor, arg.MovieID, arg.ActorID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO AppUser (
  username, password, role
) VALUES (
  $1 ,$2, $3
)
RETURNING id, username, password, role
`

type CreateUserParams struct {
	Username string   `json:"username"`
	Password string   `json:"password"`
	Role     UserRole `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Appuser, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Password, arg.Role)
	var i Appuser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const deleteActor = `-- name: DeleteActor :one
DELETE FROM Actor
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteActor(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteActor, id)
	err := row.Scan(&id)
	return id, err
}

const deleteMovie = `-- name: DeleteMovie :one
DELETE FROM Movie
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteMovie(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteMovie, id)
	err := row.Scan(&id)
	return id, err
}

const getActor = `-- name: GetActor :one
SELECT id, name, gender, birth FROM Actor
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetActor(ctx context.Context, id int32) (Actor, error) {
	row := q.db.QueryRow(ctx, getActor, id)
	var i Actor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Gender,
		&i.Birth,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, password, role FROM AppUser 
WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (Appuser, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i Appuser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, role FROM AppUser 
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (Appuser, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i Appuser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Role,
	)
	return i, err
}

const listActors = `-- name: ListActors :many
SELECT 
    actor.id, actor.name, actor.gender, actor.birth,
    JSON_AGG(json_build_object(
        'ID', Movie.id,
        'title', Movie.title,
        'plot', Movie.description,
        'release_date', Movie.release_date
    )) AS movies
FROM 
    Actor
LEFT JOIN 
    MovieActor ON Actor.id = MovieActor.actor_id
LEFT JOIN 
    Movie ON MovieActor.movie_id = Movie.id
GROUP BY 
    Actor.id
`

type ListActorsRow struct {
	ID     int32       `json:"id"`
	Name   string      `json:"name"`
	Gender GenderType  `json:"gender"`
	Birth  pgtype.Date `json:"birth"`
	Movies []byte      `json:"movies"`
}

func (q *Queries) ListActors(ctx context.Context) ([]ListActorsRow, error) {
	rows, err := q.db.Query(ctx, listActors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActorsRow
	for rows.Next() {
		var i ListActorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Gender,
			&i.Birth,
			&i.Movies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesAsc = `-- name: ListMoviesAsc :many
SELECT id, title, description, release_date, rating FROM Movie
ORDER BY $1::text ASC
`

func (q *Queries) ListMoviesAsc(ctx context.Context, property string) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesAsc, property)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ReleaseDate,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMoviesDesc = `-- name: ListMoviesDesc :many
SELECT id, title, description, release_date, rating FROM Movie
ORDER BY $1::text DESC
`

func (q *Queries) ListMoviesDesc(ctx context.Context, property string) ([]Movie, error) {
	rows, err := q.db.Query(ctx, listMoviesDesc, property)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ReleaseDate,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMovie = `-- name: SearchMovie :many
SELECT movie.id, movie.title, movie.description, movie.release_date, movie.rating
FROM Movie 
LEFT JOIN 
    MovieActor ON Movie.id = MovieActor.movie_id
LEFT JOIN 
    Actor ON MovieActor.actor_id = Actor.id
WHERE 
  title @@ to_tsquery($1)
OR
  LOWER(actor.name) LIKE LOWER($2)
`

type SearchMovieParams struct {
	ToTsquery string `json:"to_tsquery"`
	Lower     string `json:"lower"`
}

func (q *Queries) SearchMovie(ctx context.Context, arg SearchMovieParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, searchMovie, arg.ToTsquery, arg.Lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ReleaseDate,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActor = `-- name: UpdateActor :exec
UPDATE Actor
  SET name = COALESCE($2, name),
  birth = COALESCE($3, birth),
  gender = COALESCE($4, gender)
WHERE id = $1
`

type UpdateActorParams struct {
	ID     int32          `json:"id"`
	Name   pgtype.Text    `json:"name"`
	Birth  pgtype.Date    `json:"birth"`
	Gender NullGenderType `json:"gender"`
}

func (q *Queries) UpdateActor(ctx context.Context, arg UpdateActorParams) error {
	_, err := q.db.Exec(ctx, updateActor,
		arg.ID,
		arg.Name,
		arg.Birth,
		arg.Gender,
	)
	return err
}

const updateMovie = `-- name: UpdateMovie :exec
UPDATE Movie
  SET title = COALESCE($2, title),
  description = COALESCE($3, description),
  release_date = COALESCE($4, release_date),
  rating = COALESCE($5, rating)
WHERE id = $1
`

type UpdateMovieParams struct {
	ID          int32          `json:"id"`
	Title       pgtype.Text    `json:"title"`
	Description pgtype.Text    `json:"description"`
	ReleaseDate pgtype.Date    `json:"release_date"`
	Rating      pgtype.Numeric `json:"rating"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) error {
	_, err := q.db.Exec(ctx, updateMovie,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ReleaseDate,
		arg.Rating,
	)
	return err
}
